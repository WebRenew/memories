import { describe, it, expect, beforeAll } from "vitest";
import { mkdtempSync, writeFileSync, mkdirSync } from "node:fs";
import { join } from "node:path";
import { tmpdir } from "node:os";

const testDir = mkdtempSync(join(tmpdir(), "memories-diff-test-"));
process.env.MEMORIES_DATA_DIR = testDir;

// Change cwd so resolve() finds files in our temp dir
const origCwd = process.cwd();
process.chdir(testDir);

import { addMemory } from "../lib/memory.js";
import { getDb } from "../lib/db.js";

// Import internals by re-implementing the extraction logic (same as diff.ts)
function extractFileMemories(content: string): Set<string> {
  const memories = new Set<string>();
  for (const line of content.split("\n")) {
    const trimmed = line.trim();
    if (trimmed.startsWith("- ") && trimmed.length > 2) {
      memories.add(trimmed.slice(2));
    }
  }
  return memories;
}

function extractTimestamp(content: string): string | null {
  const match = content.match(/Generated by memories\.sh at (.+?)\s*-->/);
  return match ? match[1] : null;
}

describe("diff", () => {
  beforeAll(async () => {
    await getDb();
    process.chdir(testDir);
  });

  it("should extract bullet-point memories from generated file", () => {
    const content = `# Project Memories

## Rules

- Always use TypeScript strict mode
- Prefer functional patterns

## Key Decisions

- Chose PostgreSQL for JSONB support

<!-- Generated by memories.sh at 2026-01-15T10:30:00.000Z -->`;

    const memories = extractFileMemories(content);
    expect(memories.size).toBe(3);
    expect(memories.has("Always use TypeScript strict mode")).toBe(true);
    expect(memories.has("Prefer functional patterns")).toBe(true);
    expect(memories.has("Chose PostgreSQL for JSONB support")).toBe(true);
  });

  it("should extract timestamp from marker", () => {
    const content = `Some content\n\n<!-- Generated by memories.sh at 2026-01-15T10:30:00.000Z -->`;
    expect(extractTimestamp(content)).toBe("2026-01-15T10:30:00.000Z");
  });

  it("should return null timestamp when no marker", () => {
    expect(extractTimestamp("just some text")).toBeNull();
  });

  it("should detect added memories (in DB but not in file)", async () => {
    // Write a generated file with one memory
    const filePath = join(testDir, "CLAUDE.md");
    writeFileSync(filePath, `# Project Memories

## Rules

- Existing rule from file

<!-- Generated by memories.sh at 2026-01-15T10:30:00.000Z -->`);

    // Add two memories to the DB
    await addMemory("Existing rule from file", { type: "rule", global: true });
    await addMemory("Brand new rule", { type: "rule", global: true });

    // Read file and compute diff
    const { readFile } = await import("node:fs/promises");
    const content = await readFile(filePath, "utf-8");
    const fileMemories = extractFileMemories(content);

    const db = await getDb();
    const result = await db.execute("SELECT content FROM memories WHERE deleted_at IS NULL AND type IN ('rule', 'decision', 'fact')");
    const currentSet = new Set(result.rows.map((r) => String(r.content)));

    const added = [...currentSet].filter((c) => !fileMemories.has(c));
    const removed = [...fileMemories].filter((c) => !currentSet.has(c));

    expect(added).toContain("Brand new rule");
    expect(removed).toHaveLength(0);
  });

  it("should detect removed memories (in file but not in DB)", () => {
    const fileContent = `## Rules

- Rule that still exists
- Rule that was deleted

<!-- Generated by memories.sh at 2026-01-15T10:30:00.000Z -->`;

    const fileMemories = extractFileMemories(fileContent);
    const currentSet = new Set(["Rule that still exists"]);

    const removed = [...fileMemories].filter((c) => !currentSet.has(c));
    expect(removed).toContain("Rule that was deleted");
  });
});
